From: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
Date: Thu, 17 Sep 2020 18:34:04 +0300
Subject: regmap: fix page selection for noinc reads
Git-commit: 4003324856311faebb46cbd56a1616bd3f3b67c2
Patch-mainline: 5.9-rc7
References: bsc#1221162 CVE-2023-52488

Non-incrementing reads can fail if register + length crosses page
border. However for non-incrementing reads we should not check for page
border crossing. Fix this by passing additional flag to _regmap_raw_read
and passing length to _regmap_select_page basing on the flag.

Signed-off-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
Fixes: 74fe7b551f33 ("regmap: Add regmap_noinc_read API")
Link: https://lore.kernel.org/r/20200917153405.3139200-1-dmitry.baryshkov@linaro.org
Signed-off-by: Mark Brown <broonie@kernel.org>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 drivers/base/regmap/regmap.c |   10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

--- a/drivers/base/regmap/regmap.c
+++ b/drivers/base/regmap/regmap.c
@@ -2405,7 +2405,7 @@ int regmap_raw_write_async(struct regmap
 EXPORT_SYMBOL_GPL(regmap_raw_write_async);
 
 static int _regmap_raw_read(struct regmap *map, unsigned int reg, void *val,
-			    unsigned int val_len)
+			    unsigned int val_len, bool noinc)
 {
 	struct regmap_range_node *range;
 	int ret;
@@ -2418,7 +2418,7 @@ static int _regmap_raw_read(struct regma
 	range = _regmap_range_lookup(map, reg);
 	if (range) {
 		ret = _regmap_select_page(map, &reg, range,
-					  val_len / map->format.val_bytes);
+					  noinc ? 1 : val_len / map->format.val_bytes);
 		if (ret != 0)
 			return ret;
 	}
@@ -2454,7 +2454,7 @@ static int _regmap_bus_read(void *contex
 	if (!map->format.parse_val)
 		return -EINVAL;
 
-	ret = _regmap_raw_read(map, reg, map->work_buf, map->format.val_bytes);
+	ret = _regmap_raw_read(map, reg, map->work_buf, map->format.val_bytes, false);
 	if (ret == 0)
 		*val = map->format.parse_val(map->work_buf);
 
@@ -2564,7 +2564,7 @@ int regmap_raw_read(struct regmap *map,
 		}
 
 		/* Physical block read if there's no cache involved */
-		ret = _regmap_raw_read(map, reg, val, val_len);
+		ret = _regmap_raw_read(map, reg, val, val_len, false);
 
 	} else {
 		/* Otherwise go word by word for the cache; should be low
@@ -2637,7 +2637,7 @@ int regmap_noinc_read(struct regmap *map
 			read_len = map->max_raw_read;
 		else
 			read_len = val_len;
-		ret = _regmap_raw_read(map, reg, val, read_len);
+		ret = _regmap_raw_read(map, reg, val, read_len, true);
 		if (ret)
 			goto out_unlock;
 		val = ((u8 *)val) + read_len;
