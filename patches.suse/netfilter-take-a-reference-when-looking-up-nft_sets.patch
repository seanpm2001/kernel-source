From 53726fc392e5adb445fe7c6ec62ed874a28a8978 Mon Sep 17 00:00:00 2001
From: Denis Kirjanov <denis.kirjanov@suse.com>
Date: Mon, 8 Jul 2024 18:03:06 +0300
Subject: [PATCH 2/3] netfilter: take a reference when looking up nft_sets
Patch-mainline: Never, upstream has replaced the fixed code
References: bsc#1215420 CVE-2023-4244

When looking up nft_sets we should be taking a reference to
ensure that the element doesn't vanish from underneath us.

Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 net/netfilter/nf_tables_api.c | 84 ++++++++++++++++++++++++++++++++-----------
 1 file changed, 64 insertions(+), 20 deletions(-)

diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c
index a75c94d31735..596f620da2aa 100644
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@ -2604,8 +2604,11 @@ static struct nft_set *nf_tables_set_lookup(const struct nft_table *table,
 
 	list_for_each_entry(set, &table->sets, list) {
 		if (!nla_strcmp(nla, set->name) &&
-		    nft_active_genmask(set, genmask))
+		    nft_active_genmask(set, genmask)) {
+			if (!nft_set_get(set))
+				break;
 			return set;
+		}
 	}
 	return ERR_PTR(-ENOENT);
 }
@@ -2624,8 +2627,11 @@ static struct nft_set *nf_tables_set_lookup_byid(const struct net *net,
 
 			if (id == nft_trans_set_id(trans) &&
 			    set->table == table &&
-			    nft_active_genmask(set, genmask))
+			    nft_active_genmask(set, genmask)) {
+				if (!nft_set_get(set))
+					break;
 				return set;
+			}
 		}
 	}
 	return ERR_PTR(-ENOENT);
@@ -2921,17 +2927,22 @@ static int nf_tables_getset(struct net *net, struct sock *nlsk,
 		return PTR_ERR(set);
 
 	skb2 = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);
-	if (skb2 == NULL)
-		return -ENOMEM;
+	if (skb2 == NULL) {
+		err = -ENOMEM;
+		goto out_put;
+	}
 
 	err = nf_tables_fill_set(skb2, &ctx, set, NFT_MSG_NEWSET, 0);
 	if (err < 0)
 		goto err;
 
+	nft_set_put((struct nft_set *)set);
 	return nlmsg_unicast(nlsk, skb2, NETLINK_CB(skb).portid);
 
 err:
 	kfree_skb(skb2);
+out_put:
+	nft_set_put((struct nft_set *)set);
 	return err;
 }
 
@@ -3091,11 +3102,14 @@ static int nf_tables_newset(struct net *net, struct sock *nlsk,
 		if (PTR_ERR(set) != -ENOENT)
 			return PTR_ERR(set);
 	} else {
+		err = 0;
+
 		if (nlh->nlmsg_flags & NLM_F_EXCL)
-			return -EEXIST;
+			err = -EEXIST;
 		if (nlh->nlmsg_flags & NLM_F_REPLACE)
-			return -EOPNOTSUPP;
-		return 0;
+			err = -EOPNOTSUPP;
+		nft_set_put(set);
+		return err;
 	}
 
 	if (!(nlh->nlmsg_flags & NLM_F_CREATE))
@@ -3204,10 +3218,16 @@ static int nf_tables_delset(struct net *net, struct sock *nlsk,
 	set = nf_tables_set_lookup(ctx.table, nla[NFTA_SET_NAME], genmask);
 	if (IS_ERR(set))
 		return PTR_ERR(set);
-	if (!list_empty(&set->bindings))
-		return -EBUSY;
+	if (!list_empty(&set->bindings)) {
+		err = -EBUSY;
+		goto out_put;
+	}
+
+	err = nft_delset(&ctx, set);
+out_put:
+	nft_set_put(set);
 
-	return nft_delset(&ctx, set);
+	return err;
 }
 
 static int nf_tables_bind_check_setelem(const struct nft_ctx *ctx,
@@ -3463,6 +3483,7 @@ static int nf_tables_dump_set(struct sk_buff *skb, struct netlink_callback *cb)
 	struct nlattr *nest;
 	u32 portid, seq;
 	int event;
+	int err = 0;
 
 	rcu_read_lock();
 	list_for_each_entry_rcu(afi, &net->nft.af_info, list) {
@@ -3495,22 +3516,30 @@ static int nf_tables_dump_set(struct sk_buff *skb, struct netlink_callback *cb)
 
 	nlh = nlmsg_put(skb, portid, seq, event, sizeof(struct nfgenmsg),
 			NLM_F_MULTI);
-	if (nlh == NULL)
+	if (nlh == NULL) {
+		err = -ENOSPC;
 		goto nla_put_failure;
+	}
 
 	nfmsg = nlmsg_data(nlh);
 	nfmsg->nfgen_family = afi->family;
 	nfmsg->version      = NFNETLINK_V0;
 	nfmsg->res_id	    = htons(net->nft.base_seq & 0xffff);
 
-	if (nla_put_string(skb, NFTA_SET_ELEM_LIST_TABLE, table->name))
+	if (nla_put_string(skb, NFTA_SET_ELEM_LIST_TABLE, table->name)) {
+		err = -ENOSPC;
 		goto nla_put_failure;
-	if (nla_put_string(skb, NFTA_SET_ELEM_LIST_SET, set->name))
+	}
+	if (nla_put_string(skb, NFTA_SET_ELEM_LIST_SET, set->name)) {
+		err = -ENOSPC;
 		goto nla_put_failure;
+	}
 
 	nest = nla_nest_start(skb, NFTA_SET_ELEM_LIST_ELEMENTS);
-	if (nest == NULL)
+	if (nest == NULL) {
+		err = -ENOSPC;
 		goto nla_put_failure;
+	}
 
 	args.cb			= cb;
 	args.skb		= skb;
@@ -3524,6 +3553,7 @@ static int nf_tables_dump_set(struct sk_buff *skb, struct netlink_callback *cb)
 
 	nla_nest_end(skb, nest);
 	nlmsg_end(skb, nlh);
+	nft_set_put((struct nft_set *)set);
 
 	if (args.iter.err && args.iter.err != -EMSGSIZE)
 		return args.iter.err;
@@ -3535,6 +3565,7 @@ static int nf_tables_dump_set(struct sk_buff *skb, struct netlink_callback *cb)
 
 nla_put_failure:
 	rcu_read_unlock();
+	nft_set_put((struct nft_set *)set);
 	return -ENOSPC;
 }
 
@@ -3570,16 +3601,22 @@ static int nf_tables_getsetelem(struct net *net, struct sock *nlsk,
 		struct nft_set_dump_ctx *dump_ctx;
 
 		dump_ctx = kmalloc(sizeof(*dump_ctx), GFP_KERNEL);
-		if (!dump_ctx)
-			return -ENOMEM;
+		if (!dump_ctx) {
+			err = -ENOMEM;
+			goto out_put;
+		}
 
 		dump_ctx->set = set;
 		dump_ctx->ctx = ctx;
 
 		c.data = dump_ctx;
-		return netlink_dump_start(nlsk, skb, nlh, &c);
+		err = netlink_dump_start(nlsk, skb, nlh, &c);
+		goto out_put;
 	}
-	return -EOPNOTSUPP;
+	err = -EOPNOTSUPP;
+out_put:
+	nft_set_put((struct nft_set *)set);
+	return err;
 }
 
 static int nf_tables_fill_setelem_info(struct sk_buff *skb,
@@ -3983,14 +4020,18 @@ static int nf_tables_newsetelem(struct net *net, struct sock *nlsk,
 			return PTR_ERR(set);
 	}
 
-	if (!list_empty(&set->bindings) && set->flags & NFT_SET_CONSTANT)
+	if (!list_empty(&set->bindings) && set->flags & NFT_SET_CONSTANT) {
+		nft_set_put(set);
 		return -EBUSY;
+	}
 
 	nla_for_each_nested(attr, nla[NFTA_SET_ELEM_LIST_ELEMENTS], rem) {
 		err = nft_add_set_elem(&ctx, set, attr, nlh->nlmsg_flags);
 		if (err < 0)
 			break;
 	}
+
+	nft_set_put(set);
 	return err;
 }
 
@@ -4170,8 +4211,10 @@ static int nf_tables_delsetelem(struct net *net, struct sock *nlsk,
 				   genmask);
 	if (IS_ERR(set))
 		return PTR_ERR(set);
-	if (!list_empty(&set->bindings) && set->flags & NFT_SET_CONSTANT)
+	if (!list_empty(&set->bindings) && set->flags & NFT_SET_CONSTANT) {
+		nft_set_put(set);
 		return -EBUSY;
+	}
 
 	if (nla[NFTA_SET_ELEM_LIST_ELEMENTS] == NULL) {
 		struct nft_set_iter iter = {
@@ -4190,6 +4233,7 @@ static int nf_tables_delsetelem(struct net *net, struct sock *nlsk,
 
 		set->ndeact++;
 	}
+	nft_set_put(set);
 	return err;
 }
 
-- 
2.16.4

