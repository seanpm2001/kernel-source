From 186edf7e368c40d06cf727a1ad14698ea67b74ad Mon Sep 17 00:00:00 2001
From: Vratislav Bendel <vbendel@redhat.com>
Date: Wed, 2 Feb 2022 12:25:11 +0100
Subject: [PATCH] selinux: fix double free of cond_list on error paths
Git-commit: 186edf7e368c40d06cf727a1ad14698ea67b74ad
Patch-mainline: v5.17-rc3
References: bsc#1226699 CVE-2022-48740

On error path from cond_read_list() and duplicate_policydb_cond_list()
the cond_list_destroy() gets called a second time in caller functions,
resulting in NULL pointer deref.  Fix this by resetting the
cond_list_len to 0 in cond_list_destroy(), making subsequent calls a
noop.

Also consistently reset the cond_list pointer to NULL after freeing.

[[ backport notes: This is quite different from the original patch
because we don't keep the cond_list in an array like upstream. Still
this is reachable in parallel from multiple error paths, so we better
ensure the list is properly cleaned. ]]

Cc: stable@vger.kernel.org
Signed-off-by: Vratislav Bendel <vbendel@redhat.com>
[PM: fix line lengths in the description]
Signed-off-by: Paul Moore <paul@paul-moore.com>
Signed-off-by: Gabriel Krisman Bertazi <krisman@suse.de>
---
 security/selinux/ss/conditional.c |    1 +
 1 file changed, 1 insertion(+)

--- a/security/selinux/ss/conditional.c
+++ b/security/selinux/ss/conditional.c
@@ -171,6 +171,7 @@ void cond_policydb_destroy(struct policy
 	kfree(p->bool_val_to_struct);
 	avtab_destroy(&p->te_cond_avtab);
 	cond_list_destroy(p->cond_list);
+	p->cond_list = NULL;
 }
 
 int cond_init_bool_indexes(struct policydb *p)
