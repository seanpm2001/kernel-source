From 4d4d2d4346857bf778fafaa97d6f76bb1663e3c9 Mon Sep 17 00:00:00 2001
From: Marco Pagani <marpagan@redhat.com>
Date: Tue, 5 Mar 2024 20:29:26 +0100
Subject: [PATCH] fpga: manager: add owner module and take its refcount
Git-commit: 4d4d2d4346857bf778fafaa97d6f76bb1663e3c9
Patch-mainline: v6.10-rc1
References: CVE-2024-37021 bsc#1226950

[ backport note: majorly rewritten to match with the old code base
  using fpga_mgr_create().  The kABI workaround is also embedded into
  this patch exceptionally for the ease of maintenance -- tiwai ]

The current implementation of the fpga manager assumes that the low-level
module registers a driver for the parent device and uses its owner pointer
to take the module's refcount. This approach is problematic since it can
lead to a null pointer dereference while attempting to get the manager if
the parent device does not have a driver.

To address this problem, add a module owner pointer to the fpga_manager
struct and use it to take the module's refcount. Modify the functions for
registering the manager to take an additional owner module parameter and
rename them to avoid conflicts. Use the old function names for helper
macros that automatically set the module that registers the manager as the
owner. This ensures compatibility with existing low-level control modules
and reduces the chances of registering a manager without setting the owner.

Also, update the documentation to keep it consistent with the new interface
for registering an fpga manager.

Other changes: opportunistically move put_device() from __fpga_mgr_get() to
fpga_mgr_get() and of_fpga_mgr_get() to improve code clarity since the
manager device is taken in these functions.

Fixes: 654ba4cc0f3e ("fpga manager: ensure lifetime with of_fpga_mgr_get")
Suggested-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Suggested-by: Xu Yilun <yilun.xu@intel.com>
Signed-off-by: Marco Pagani <marpagan@redhat.com>
Acked-by: Xu Yilun <yilun.xu@intel.com>
Link: https://lore.kernel.org/r/20240305192926.84886-1-marpagan@redhat.com
Signed-off-by: Xu Yilun <yilun.xu@linux.intel.com>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/fpga/fpga-mgr.c       |   62 +++++++++++++++++++++++++++---------------
 include/linux/fpga/fpga-mgr.h |   12 ++++++--
 2 files changed, 50 insertions(+), 24 deletions(-)

--- a/drivers/fpga/fpga-mgr.c
+++ b/drivers/fpga/fpga-mgr.c
@@ -455,20 +455,16 @@ static struct attribute *fpga_mgr_attrs[
 };
 ATTRIBUTE_GROUPS(fpga_mgr);
 
-static struct fpga_manager *__fpga_mgr_get(struct device *dev)
+static struct fpga_manager *__fpga_mgr_get(struct device *mgr_dev)
 {
 	struct fpga_manager *mgr;
 
-	mgr = to_fpga_manager(dev);
+	mgr = to_fpga_manager(mgr_dev);
 
-	if (!try_module_get(dev->parent->driver->owner))
-		goto err_dev;
+	if (!try_module_get(mgr->mops_owner))
+		mgr = ERR_PTR(-ENODEV);
 
 	return mgr;
-
-err_dev:
-	put_device(dev);
-	return ERR_PTR(-ENODEV);
 }
 
 static int fpga_mgr_dev_match(struct device *dev, const void *data)
@@ -484,12 +480,18 @@ static int fpga_mgr_dev_match(struct dev
  */
 struct fpga_manager *fpga_mgr_get(struct device *dev)
 {
-	struct device *mgr_dev = class_find_device(fpga_mgr_class, NULL, dev,
-						   fpga_mgr_dev_match);
+	struct fpga_manager *mgr;
+	struct device *mgr_dev;
+
+	mgr_dev = class_find_device(fpga_mgr_class, NULL, dev, fpga_mgr_dev_match);
 	if (!mgr_dev)
 		return ERR_PTR(-ENODEV);
 
-	return __fpga_mgr_get(mgr_dev);
+	mgr = __fpga_mgr_get(mgr_dev);
+	if (IS_ERR(mgr))
+		put_device(mgr_dev);
+
+	return mgr;
 }
 EXPORT_SYMBOL_GPL(fpga_mgr_get);
 
@@ -507,14 +509,19 @@ static int fpga_mgr_of_node_match(struct
  */
 struct fpga_manager *of_fpga_mgr_get(struct device_node *node)
 {
-	struct device *dev;
+	struct fpga_manager *mgr;
+	struct device *mgr_dev;
 
-	dev = class_find_device(fpga_mgr_class, NULL, node,
-				fpga_mgr_of_node_match);
-	if (!dev)
+	mgr_dev = class_find_device(fpga_mgr_class, NULL, node,
+				    fpga_mgr_of_node_match);
+	if (!mgr_dev)
 		return ERR_PTR(-ENODEV);
 
-	return __fpga_mgr_get(dev);
+	mgr = __fpga_mgr_get(mgr_dev);
+	if (IS_ERR(mgr))
+		put_device(mgr_dev);
+
+	return mgr;
 }
 EXPORT_SYMBOL_GPL(of_fpga_mgr_get);
 
@@ -524,7 +531,7 @@ EXPORT_SYMBOL_GPL(of_fpga_mgr_get);
  */
 void fpga_mgr_put(struct fpga_manager *mgr)
 {
-	module_put(mgr->dev.parent->driver->owner);
+	module_put(mgr->mops_owner);
 	put_device(&mgr->dev);
 }
 EXPORT_SYMBOL_GPL(fpga_mgr_put);
@@ -563,7 +570,7 @@ void fpga_mgr_unlock(struct fpga_manager
 EXPORT_SYMBOL_GPL(fpga_mgr_unlock);
 
 /**
- * fpga_mgr_create - create and initialize a FPGA manager struct
+ * __fpga_mgr_create - create and initialize a FPGA manager struct
  * @dev:	fpga manager device from pdev
  * @name:	fpga manager name
  * @mops:	pointer to structure of fpga manager ops
@@ -571,9 +578,10 @@ EXPORT_SYMBOL_GPL(fpga_mgr_unlock);
  *
  * Return: pointer to struct fpga_manager or NULL
  */
-struct fpga_manager *fpga_mgr_create(struct device *dev, const char *name,
-				     const struct fpga_manager_ops *mops,
-				     void *priv)
+struct fpga_manager *
+__fpga_mgr_create(struct device *dev, const char *name,
+		  const struct fpga_manager_ops *mops,
+		  void *priv, struct module *owner)
 {
 	struct fpga_manager *mgr;
 	int id, ret;
@@ -602,6 +610,8 @@ struct fpga_manager *fpga_mgr_create(str
 
 	mutex_init(&mgr->ref_mutex);
 
+	mgr->mops_owner = owner;
+
 	mgr->name = name;
 	mgr->mops = mops;
 	mgr->priv = priv;
@@ -626,6 +636,16 @@ error_kfree:
 
 	return NULL;
 }
+EXPORT_SYMBOL_GPL(__fpga_mgr_create);
+
+/* FIXME: provided only for kABI compatibility */
+#undef fpga_mgr_create
+struct fpga_manager *
+fpga_mgr_create(struct device *dev, const char *name,
+		const struct fpga_manager_ops *mops, void *priv)
+{
+	return __fpga_mgr_create(dev, name, mops, priv, dev->parent->driver->owner);
+}
 EXPORT_SYMBOL_GPL(fpga_mgr_create);
 
 /**
--- a/include/linux/fpga/fpga-mgr.h
+++ b/include/linux/fpga/fpga-mgr.h
@@ -161,6 +161,7 @@ struct fpga_compat_id {
  * @state: state of fpga manager
  * @compat_id: FPGA manager id for compatibility check.
  * @mops: pointer to struct of fpga manager ops
+ * @mops_owner: module containing the mops
  * @priv: low level driver private date
  */
 struct fpga_manager {
@@ -171,6 +172,9 @@ struct fpga_manager {
 	struct fpga_compat_id *compat_id;
 	const struct fpga_manager_ops *mops;
 	void *priv;
+#ifndef __GENKSYMS__
+	struct module *mops_owner;
+#endif
 };
 
 #define to_fpga_manager(d) container_of(d, struct fpga_manager, dev)
@@ -190,9 +194,11 @@ struct fpga_manager *fpga_mgr_get(struct
 
 void fpga_mgr_put(struct fpga_manager *mgr);
 
-struct fpga_manager *fpga_mgr_create(struct device *dev, const char *name,
-				     const struct fpga_manager_ops *mops,
-				     void *priv);
+struct fpga_manager *__fpga_mgr_create(struct device *dev, const char *name,
+				       const struct fpga_manager_ops *mops,
+				       void *priv, struct module *owner);
+#define fpga_mgr_create(dev, name, mops, priv)		\
+	__fpga_mgr_create(dev, name, mops, priv, THIS_MODULE)
 void fpga_mgr_free(struct fpga_manager *mgr);
 int fpga_mgr_register(struct fpga_manager *mgr);
 void fpga_mgr_unregister(struct fpga_manager *mgr);
