From: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
Date: Thu, 17 Sep 2020 18:34:05 +0300
Subject: regmap: fix page selection for noinc writes
Git-commit: 05669b63170771d554854c0e465b76dc98fc7c84
Patch-mainline: 5.9-rc7
References: bsc#1221162 CVE-2023-52488

Non-incrementing writes can fail if register + length crosses page
border. However for non-incrementing writes we should not check for page
border crossing. Fix this by passing additional flag to _regmap_raw_write
and passing length to _regmap_select_page basing on the flag.

Signed-off-by: Dmitry Baryshkov <dmitry.baryshkov@linaro.org>
Fixes: cdf6b11daa77 ("regmap: Add regmap_noinc_write API")
Link: https://lore.kernel.org/r/20200917153405.3139200-2-dmitry.baryshkov@linaro.org
Signed-off-by: Mark Brown <broonie@kernel.org>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 drivers/base/regmap/internal.h |    2 +-
 drivers/base/regmap/regcache.c |    2 +-
 drivers/base/regmap/regmap.c   |   24 ++++++++++++++----------
 3 files changed, 16 insertions(+), 12 deletions(-)

--- a/drivers/base/regmap/internal.h
+++ b/drivers/base/regmap/internal.h
@@ -252,7 +252,7 @@ bool regcache_set_val(struct regmap *map
 int regcache_lookup_reg(struct regmap *map, unsigned int reg);
 
 int _regmap_raw_write(struct regmap *map, unsigned int reg,
-		      const void *val, size_t val_len);
+		      const void *val, size_t val_len, bool noinc);
 
 void regmap_async_complete_cb(struct regmap_async *async, int ret);
 
--- a/drivers/base/regmap/regcache.c
+++ b/drivers/base/regmap/regcache.c
@@ -719,7 +719,7 @@ static int regcache_sync_block_raw_flush
 
 	map->cache_bypass = true;
 
-	ret = _regmap_raw_write(map, base, *data, count * val_bytes);
+	ret = _regmap_raw_write(map, base, *data, count * val_bytes, false);
 	if (ret)
 		dev_err(map->dev, "Unable to sync registers %#x-%#x. %d\n",
 			base, cur - map->reg_stride, ret);
--- a/drivers/base/regmap/regmap.c
+++ b/drivers/base/regmap/regmap.c
@@ -1375,7 +1375,7 @@ static void regmap_set_work_buf_flag_mas
 }
 
 int _regmap_raw_write(struct regmap *map, unsigned int reg,
-		      const void *val, size_t val_len)
+		      const void *val, size_t val_len, bool noinc)
 {
 	struct regmap_range_node *range;
 	unsigned long flags;
@@ -1427,7 +1427,7 @@ int _regmap_raw_write(struct regmap *map
 			dev_dbg(map->dev, "Writing window %d/%zu\n",
 				win_residue, val_len / map->format.val_bytes);
 			ret = _regmap_raw_write(map, reg, val, win_residue *
-						map->format.val_bytes);
+						map->format.val_bytes, noinc);
 			if (ret != 0)
 				return ret;
 
@@ -1441,7 +1441,7 @@ int _regmap_raw_write(struct regmap *map
 			win_residue = range->window_len - win_offset;
 		}
 
-		ret = _regmap_select_page(map, &reg, range, val_num);
+		ret = _regmap_select_page(map, &reg, range, noinc ? 1 : val_num);
 		if (ret != 0)
 			return ret;
 	}
@@ -1649,7 +1649,8 @@ static int _regmap_bus_raw_write(void *c
 				 map->work_buf +
 				 map->format.reg_bytes +
 				 map->format.pad_bytes,
-				 map->format.val_bytes);
+				 map->format.val_bytes,
+				 false);
 }
 
 static inline void *_regmap_map_get_context(struct regmap *map)
@@ -1774,7 +1775,7 @@ int regmap_raw_write(struct regmap *map,
 
 	map->lock(map->lock_arg);
 
-	ret = _regmap_raw_write(map, reg, val, val_len);
+	ret = _regmap_raw_write(map, reg, val, val_len, false);
 
 	map->unlock(map->lock_arg);
 
@@ -1832,7 +1833,7 @@ int regmap_noinc_write(struct regmap *ma
 			write_len = map->max_raw_write;
 		else
 			write_len = val_len;
-		ret = _regmap_raw_write(map, reg, val, write_len);
+		ret = _regmap_raw_write(map, reg, val, write_len, true);
 		if (ret)
 			goto out_unlock;
 		val = ((u8 *)val) + write_len;
@@ -2030,7 +2031,8 @@ out:
 			ret = _regmap_raw_write(map,
 						reg + (i * chunk_stride),
 						wval + (i * chunk_size),
-						chunk_size);
+						chunk_size,
+						false);
 			if (ret)
 				break;
 		}
@@ -2039,7 +2041,8 @@ out:
 		if (!ret && chunk_size * i < total_size) {
 			ret = _regmap_raw_write(map, reg + (i * chunk_stride),
 						wval + (i * chunk_size),
-						total_size - i * chunk_size);
+						total_size - i * chunk_size,
+						false);
 		}
 		map->unlock(map->lock_arg);
 
@@ -2059,7 +2062,8 @@ out:
 			map->format.parse_inplace(wval + i);
 
 		map->lock(map->lock_arg);
-		ret = _regmap_raw_write(map, reg, wval, val_bytes * val_count);
+		ret = _regmap_raw_write(map, reg, wval, val_bytes * val_count,
+					false);
 		map->unlock(map->lock_arg);
 
 		kfree(wval);
@@ -2394,7 +2398,7 @@ int regmap_raw_write_async(struct regmap
 
 	map->async = true;
 
-	ret = _regmap_raw_write(map, reg, val, val_len);
+	ret = _regmap_raw_write(map, reg, val, val_len, false);
 
 	map->async = false;
 
