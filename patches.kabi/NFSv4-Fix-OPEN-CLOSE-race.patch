From: NeilBrown <neilb@suse.de>
Subject: Fix kabi for: NFSv4: Fix OPEN / CLOSE race
References: git-fixes
Patch-mainline: Never, kabi

Adding a waitq to the nfs4_state breaks the kabi.
So instead use wake_up_bit which provides its own
waitq, and wait on that waitq.

Signed-off-by: NeilBrown <neilb@suse.de>
---
 fs/nfs/nfs4_fs.h   |    2 --
 fs/nfs/nfs4proc.c  |    8 +++++---
 fs/nfs/nfs4state.c |    1 -
 3 files changed, 5 insertions(+), 6 deletions(-)

--- a/fs/nfs/nfs4_fs.h
+++ b/fs/nfs/nfs4_fs.h
@@ -185,8 +185,6 @@ struct nfs4_state {
 	unsigned int n_rdwr;		/* Number of read/write references */
 	fmode_t state;			/* State on the server (R,W, or RW) */
 	atomic_t count;
-
-	wait_queue_head_t waitq;
 };
 
 
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -1397,7 +1397,7 @@ static bool nfs_open_stateid_recover_ope
 static void nfs_state_log_update_open_stateid(struct nfs4_state *state)
 {
 	if (test_and_clear_bit(NFS_STATE_CHANGE_WAIT, &state->flags))
-		wake_up_all(&state->waitq);
+		wake_up_bit(&state->flags, NFS_STATE_CHANGE_WAIT);
 }
 
 static void nfs_state_log_out_of_order_open_stateid(struct nfs4_state *state,
@@ -1518,6 +1518,8 @@ static void nfs_set_open_stateid_locked(
 		const nfs4_stateid *stateid, nfs4_stateid *freeme)
 {
 	DEFINE_WAIT(wait);
+	struct wait_queue_head *wq_head = bit_waitqueue(&state->flags,
+							NFS_STATE_CHANGE_WAIT);
 	int status = 0;
 	for (;;) {
 
@@ -1531,7 +1533,7 @@ static void nfs_set_open_stateid_locked(
 		if (!nfs4_has_session(NFS_SERVER(state->inode)->nfs_client))
 			break;
 
-		prepare_to_wait(&state->waitq, &wait, TASK_KILLABLE);
+		prepare_to_wait(wq_head, &wait, TASK_KILLABLE);
 		/*
 		 * Ensure we process the state changes in the same order
 		 * in which the server processed them by delaying the
@@ -1547,7 +1549,7 @@ static void nfs_set_open_stateid_locked(
 				status = 0;
 		} else
 			status = -EINTR;
-		finish_wait(&state->waitq, &wait);
+		finish_wait(wq_head, &wait);
 		rcu_read_lock();
 		spin_lock(&state->owner->so_lock);
 		write_seqlock(&state->seqlock);
 	}
-	finish_wait(&state->waitq, &wait);
+	finish_wait(wq_head, &wbq_entry.wq_entry);
 
 	if (!nfs4_stateid_match_other(stateid, &state->open_stateid)) {
 		nfs4_stateid_copy(freeme, &state->open_stateid);
--- a/fs/nfs/nfs4state.c
+++ b/fs/nfs/nfs4state.c
@@ -656,7 +656,6 @@ nfs4_alloc_open_state(void)
 	INIT_LIST_HEAD(&state->lock_states);
 	spin_lock_init(&state->state_lock);
 	seqlock_init(&state->seqlock);
-	init_waitqueue_head(&state->waitq);
 	return state;
 }
 
